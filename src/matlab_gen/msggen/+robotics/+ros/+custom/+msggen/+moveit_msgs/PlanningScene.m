classdef PlanningScene < robotics.ros.Message
    %PlanningScene MATLAB implementation of moveit_msgs/PlanningScene
    %   This class was automatically generated by
    %   robotics.ros.msg.internal.gen.MessageClassGenerator.
    
    %   Copyright 2014-2018 The MathWorks, Inc.
    
    %#ok<*INUSD>
    
    properties (Constant)
        MessageType = 'moveit_msgs/PlanningScene' % The ROS message type
    end
    
    properties (Constant, Hidden)
        MD5Checksum = '89aac6d20db967ba716cba5a86b1b9d5' % The MD5 Checksum of the message definition
    end
    
    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    properties (Constant, Access = protected)
        GeometryMsgsTransformStampedClass = robotics.ros.msg.internal.MessageFactory.getClassForType('geometry_msgs/TransformStamped') % Dispatch to MATLAB class for message type geometry_msgs/TransformStamped
        MoveitMsgsAllowedCollisionMatrixClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/AllowedCollisionMatrix') % Dispatch to MATLAB class for message type moveit_msgs/AllowedCollisionMatrix
        MoveitMsgsLinkPaddingClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/LinkPadding') % Dispatch to MATLAB class for message type moveit_msgs/LinkPadding
        MoveitMsgsLinkScaleClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/LinkScale') % Dispatch to MATLAB class for message type moveit_msgs/LinkScale
        MoveitMsgsObjectColorClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/ObjectColor') % Dispatch to MATLAB class for message type moveit_msgs/ObjectColor
        MoveitMsgsPlanningSceneWorldClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/PlanningSceneWorld') % Dispatch to MATLAB class for message type moveit_msgs/PlanningSceneWorld
        MoveitMsgsRobotStateClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/RobotState') % Dispatch to MATLAB class for message type moveit_msgs/RobotState
    end
    
    properties (Dependent)
        Name
        RobotState
        RobotModelName
        AllowedCollisionMatrix
        World
        IsDiff
        FixedFrameTransforms
        LinkPadding
        LinkScale
        ObjectColors
    end
    
    properties (Access = protected)
        Cache = struct('RobotState', [], 'FixedFrameTransforms', [], 'AllowedCollisionMatrix', [], 'LinkPadding', [], 'LinkScale', [], 'ObjectColors', [], 'World', []) % The cache for fast data access
    end
    
    properties (Constant, Hidden)
        PropertyList = {'AllowedCollisionMatrix', 'FixedFrameTransforms', 'IsDiff', 'LinkPadding', 'LinkScale', 'Name', 'ObjectColors', 'RobotModelName', 'RobotState', 'World'} % List of non-constant message properties
        ROSPropertyList = {'allowed_collision_matrix', 'fixed_frame_transforms', 'is_diff', 'link_padding', 'link_scale', 'name', 'object_colors', 'robot_model_name', 'robot_state', 'world'} % List of non-constant ROS message properties
    end
    
    methods
        function obj = PlanningScene(msg)
            %PlanningScene Construct the message object PlanningScene
            import com.mathworks.toolbox.robotics.ros.message.MessageInfo;
            
            % Support default constructor
            if nargin == 0
                obj.JavaMessage = obj.createNewJavaMessage;
                return;
            end
            
            % Construct appropriate empty array
            if isempty(msg)
                obj = obj.empty(0,1);
                return;
            end
            
            % Make scalar construction fast
            if isscalar(msg)
                % Check for correct input class
                if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
                    error(message('robotics:ros:message:NoTypeMatch', obj.MessageType, ...
                        char(MessageInfo.getType(msg(1))) ));
                end
                obj.JavaMessage = msg(1);
                return;
            end
            
            % Check that this is a vector of scalar messages. Since this
            % is an object array, use arrayfun to verify.
            if ~all(arrayfun(@isscalar, msg))
                error(message('robotics:ros:message:MessageArraySizeError'));
            end
            
            % Check that all messages in the array have the correct type
            if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
                error(message('robotics:ros:message:NoTypeMatchArray', obj.MessageType));
            end
            
            % Construct array of objects if necessary
            objType = class(obj);
            for i = 1:length(msg)
                obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
            end
        end
        
        function name = get.Name(obj)
            %get.Name Get the value for property Name
            name = char(obj.JavaMessage.getName);
        end
        
        function set.Name(obj, name)
            %set.Name Set the value for property Name
            validateattributes(name, {'char'}, {}, 'PlanningScene', 'Name');
            
            obj.JavaMessage.setName(name);
        end
        
        function robotstate = get.RobotState(obj)
            %get.RobotState Get the value for property RobotState
            if isempty(obj.Cache.RobotState)
                obj.Cache.RobotState = feval(obj.MoveitMsgsRobotStateClass, obj.JavaMessage.getRobotState);
            end
            robotstate = obj.Cache.RobotState;
        end
        
        function set.RobotState(obj, robotstate)
            %set.RobotState Set the value for property RobotState
            validateattributes(robotstate, {obj.MoveitMsgsRobotStateClass}, {'nonempty', 'scalar'}, 'PlanningScene', 'RobotState');
            
            obj.JavaMessage.setRobotState(robotstate.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.RobotState)
                obj.Cache.RobotState.setJavaObject(robotstate.getJavaObject);
            end
        end
        
        function robotmodelname = get.RobotModelName(obj)
            %get.RobotModelName Get the value for property RobotModelName
            robotmodelname = char(obj.JavaMessage.getRobotModelName);
        end
        
        function set.RobotModelName(obj, robotmodelname)
            %set.RobotModelName Set the value for property RobotModelName
            validateattributes(robotmodelname, {'char'}, {}, 'PlanningScene', 'RobotModelName');
            
            obj.JavaMessage.setRobotModelName(robotmodelname);
        end
        
        function allowedcollisionmatrix = get.AllowedCollisionMatrix(obj)
            %get.AllowedCollisionMatrix Get the value for property AllowedCollisionMatrix
            if isempty(obj.Cache.AllowedCollisionMatrix)
                obj.Cache.AllowedCollisionMatrix = feval(obj.MoveitMsgsAllowedCollisionMatrixClass, obj.JavaMessage.getAllowedCollisionMatrix);
            end
            allowedcollisionmatrix = obj.Cache.AllowedCollisionMatrix;
        end
        
        function set.AllowedCollisionMatrix(obj, allowedcollisionmatrix)
            %set.AllowedCollisionMatrix Set the value for property AllowedCollisionMatrix
            validateattributes(allowedcollisionmatrix, {obj.MoveitMsgsAllowedCollisionMatrixClass}, {'nonempty', 'scalar'}, 'PlanningScene', 'AllowedCollisionMatrix');
            
            obj.JavaMessage.setAllowedCollisionMatrix(allowedcollisionmatrix.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.AllowedCollisionMatrix)
                obj.Cache.AllowedCollisionMatrix.setJavaObject(allowedcollisionmatrix.getJavaObject);
            end
        end
        
        function world = get.World(obj)
            %get.World Get the value for property World
            if isempty(obj.Cache.World)
                obj.Cache.World = feval(obj.MoveitMsgsPlanningSceneWorldClass, obj.JavaMessage.getWorld);
            end
            world = obj.Cache.World;
        end
        
        function set.World(obj, world)
            %set.World Set the value for property World
            validateattributes(world, {obj.MoveitMsgsPlanningSceneWorldClass}, {'nonempty', 'scalar'}, 'PlanningScene', 'World');
            
            obj.JavaMessage.setWorld(world.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.World)
                obj.Cache.World.setJavaObject(world.getJavaObject);
            end
        end
        
        function isdiff = get.IsDiff(obj)
            %get.IsDiff Get the value for property IsDiff
            isdiff = logical(obj.JavaMessage.getIsDiff);
        end
        
        function set.IsDiff(obj, isdiff)
            %set.IsDiff Set the value for property IsDiff
            validateattributes(isdiff, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'PlanningScene', 'IsDiff');
            
            obj.JavaMessage.setIsDiff(isdiff);
        end
        
        function fixedframetransforms = get.FixedFrameTransforms(obj)
            %get.FixedFrameTransforms Get the value for property FixedFrameTransforms
            if isempty(obj.Cache.FixedFrameTransforms)
                javaArray = obj.JavaMessage.getFixedFrameTransforms;
                array = obj.readJavaArray(javaArray, obj.GeometryMsgsTransformStampedClass);
                obj.Cache.FixedFrameTransforms = feval(obj.GeometryMsgsTransformStampedClass, array);
            end
            fixedframetransforms = obj.Cache.FixedFrameTransforms;
        end
        
        function set.FixedFrameTransforms(obj, fixedframetransforms)
            %set.FixedFrameTransforms Set the value for property FixedFrameTransforms
            if ~isvector(fixedframetransforms) && isempty(fixedframetransforms)
                % Allow empty [] input
                fixedframetransforms = feval([obj.GeometryMsgsTransformStampedClass '.empty'], 0, 1);
            end
            
            validateattributes(fixedframetransforms, {obj.GeometryMsgsTransformStampedClass}, {'vector'}, 'PlanningScene', 'FixedFrameTransforms');
            
            javaArray = obj.JavaMessage.getFixedFrameTransforms;
            array = obj.writeJavaArray(fixedframetransforms, javaArray, obj.GeometryMsgsTransformStampedClass);
            obj.JavaMessage.setFixedFrameTransforms(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.FixedFrameTransforms)
                obj.Cache.FixedFrameTransforms = [];
                obj.Cache.FixedFrameTransforms = obj.FixedFrameTransforms;
            end
        end
        
        function linkpadding = get.LinkPadding(obj)
            %get.LinkPadding Get the value for property LinkPadding
            if isempty(obj.Cache.LinkPadding)
                javaArray = obj.JavaMessage.getLinkPadding;
                array = obj.readJavaArray(javaArray, obj.MoveitMsgsLinkPaddingClass);
                obj.Cache.LinkPadding = feval(obj.MoveitMsgsLinkPaddingClass, array);
            end
            linkpadding = obj.Cache.LinkPadding;
        end
        
        function set.LinkPadding(obj, linkpadding)
            %set.LinkPadding Set the value for property LinkPadding
            if ~isvector(linkpadding) && isempty(linkpadding)
                % Allow empty [] input
                linkpadding = feval([obj.MoveitMsgsLinkPaddingClass '.empty'], 0, 1);
            end
            
            validateattributes(linkpadding, {obj.MoveitMsgsLinkPaddingClass}, {'vector'}, 'PlanningScene', 'LinkPadding');
            
            javaArray = obj.JavaMessage.getLinkPadding;
            array = obj.writeJavaArray(linkpadding, javaArray, obj.MoveitMsgsLinkPaddingClass);
            obj.JavaMessage.setLinkPadding(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.LinkPadding)
                obj.Cache.LinkPadding = [];
                obj.Cache.LinkPadding = obj.LinkPadding;
            end
        end
        
        function linkscale = get.LinkScale(obj)
            %get.LinkScale Get the value for property LinkScale
            if isempty(obj.Cache.LinkScale)
                javaArray = obj.JavaMessage.getLinkScale;
                array = obj.readJavaArray(javaArray, obj.MoveitMsgsLinkScaleClass);
                obj.Cache.LinkScale = feval(obj.MoveitMsgsLinkScaleClass, array);
            end
            linkscale = obj.Cache.LinkScale;
        end
        
        function set.LinkScale(obj, linkscale)
            %set.LinkScale Set the value for property LinkScale
            if ~isvector(linkscale) && isempty(linkscale)
                % Allow empty [] input
                linkscale = feval([obj.MoveitMsgsLinkScaleClass '.empty'], 0, 1);
            end
            
            validateattributes(linkscale, {obj.MoveitMsgsLinkScaleClass}, {'vector'}, 'PlanningScene', 'LinkScale');
            
            javaArray = obj.JavaMessage.getLinkScale;
            array = obj.writeJavaArray(linkscale, javaArray, obj.MoveitMsgsLinkScaleClass);
            obj.JavaMessage.setLinkScale(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.LinkScale)
                obj.Cache.LinkScale = [];
                obj.Cache.LinkScale = obj.LinkScale;
            end
        end
        
        function objectcolors = get.ObjectColors(obj)
            %get.ObjectColors Get the value for property ObjectColors
            if isempty(obj.Cache.ObjectColors)
                javaArray = obj.JavaMessage.getObjectColors;
                array = obj.readJavaArray(javaArray, obj.MoveitMsgsObjectColorClass);
                obj.Cache.ObjectColors = feval(obj.MoveitMsgsObjectColorClass, array);
            end
            objectcolors = obj.Cache.ObjectColors;
        end
        
        function set.ObjectColors(obj, objectcolors)
            %set.ObjectColors Set the value for property ObjectColors
            if ~isvector(objectcolors) && isempty(objectcolors)
                % Allow empty [] input
                objectcolors = feval([obj.MoveitMsgsObjectColorClass '.empty'], 0, 1);
            end
            
            validateattributes(objectcolors, {obj.MoveitMsgsObjectColorClass}, {'vector'}, 'PlanningScene', 'ObjectColors');
            
            javaArray = obj.JavaMessage.getObjectColors;
            array = obj.writeJavaArray(objectcolors, javaArray, obj.MoveitMsgsObjectColorClass);
            obj.JavaMessage.setObjectColors(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.ObjectColors)
                obj.Cache.ObjectColors = [];
                obj.Cache.ObjectColors = obj.ObjectColors;
            end
        end
    end
    
    methods (Access = protected)
        function resetCache(obj)
            %resetCache Resets any cached properties
            obj.Cache.RobotState = [];
            obj.Cache.FixedFrameTransforms = [];
            obj.Cache.AllowedCollisionMatrix = [];
            obj.Cache.LinkPadding = [];
            obj.Cache.LinkScale = [];
            obj.Cache.ObjectColors = [];
            obj.Cache.World = [];
        end
        
        function cpObj = copyElement(obj)
            %copyElement Implements deep copy behavior for message
            
            % Call default copy method for shallow copy
            cpObj = copyElement@robotics.ros.Message(obj);
            
            % Clear any existing cached properties
            cpObj.resetCache;
            
            % Create a new Java message object
            cpObj.JavaMessage = obj.createNewJavaMessage;
            
            % Iterate over all primitive properties
            cpObj.Name = obj.Name;
            cpObj.RobotModelName = obj.RobotModelName;
            cpObj.IsDiff = obj.IsDiff;
            
            % Recursively copy compound properties
            cpObj.RobotState = copy(obj.RobotState);
            cpObj.AllowedCollisionMatrix = copy(obj.AllowedCollisionMatrix);
            cpObj.World = copy(obj.World);
            cpObj.FixedFrameTransforms = copy(obj.FixedFrameTransforms);
            cpObj.LinkPadding = copy(obj.LinkPadding);
            cpObj.LinkScale = copy(obj.LinkScale);
            cpObj.ObjectColors = copy(obj.ObjectColors);
        end
        
        function reload(obj, strObj)
            %reload Called by loadobj to assign properties
            obj.Name = strObj.Name;
            obj.RobotModelName = strObj.RobotModelName;
            obj.IsDiff = strObj.IsDiff;
            obj.RobotState = feval([obj.MoveitMsgsRobotStateClass '.loadobj'], strObj.RobotState);
            obj.AllowedCollisionMatrix = feval([obj.MoveitMsgsAllowedCollisionMatrixClass '.loadobj'], strObj.AllowedCollisionMatrix);
            obj.World = feval([obj.MoveitMsgsPlanningSceneWorldClass '.loadobj'], strObj.World);
            FixedFrameTransformsCell = arrayfun(@(x) feval([obj.GeometryMsgsTransformStampedClass '.loadobj'], x), strObj.FixedFrameTransforms, 'UniformOutput', false);
            obj.FixedFrameTransforms = vertcat(FixedFrameTransformsCell{:});
            LinkPaddingCell = arrayfun(@(x) feval([obj.MoveitMsgsLinkPaddingClass '.loadobj'], x), strObj.LinkPadding, 'UniformOutput', false);
            obj.LinkPadding = vertcat(LinkPaddingCell{:});
            LinkScaleCell = arrayfun(@(x) feval([obj.MoveitMsgsLinkScaleClass '.loadobj'], x), strObj.LinkScale, 'UniformOutput', false);
            obj.LinkScale = vertcat(LinkScaleCell{:});
            ObjectColorsCell = arrayfun(@(x) feval([obj.MoveitMsgsObjectColorClass '.loadobj'], x), strObj.ObjectColors, 'UniformOutput', false);
            obj.ObjectColors = vertcat(ObjectColorsCell{:});
        end
    end
    
    methods (Access = ?robotics.ros.Message)
        function strObj = saveobj(obj)
            %saveobj Implements saving of message to MAT file
            
            % Return an empty element if object array is empty
            if isempty(obj)
                strObj = struct.empty;
                return
            end
            
            strObj.Name = obj.Name;
            strObj.RobotModelName = obj.RobotModelName;
            strObj.IsDiff = obj.IsDiff;
            strObj.RobotState = saveobj(obj.RobotState);
            strObj.AllowedCollisionMatrix = saveobj(obj.AllowedCollisionMatrix);
            strObj.World = saveobj(obj.World);
            strObj.FixedFrameTransforms = arrayfun(@(x) saveobj(x), obj.FixedFrameTransforms);
            strObj.LinkPadding = arrayfun(@(x) saveobj(x), obj.LinkPadding);
            strObj.LinkScale = arrayfun(@(x) saveobj(x), obj.LinkScale);
            strObj.ObjectColors = arrayfun(@(x) saveobj(x), obj.ObjectColors);
        end
    end
    
    methods (Static, Access = {?matlab.unittest.TestCase, ?robotics.ros.Message})
        function obj = loadobj(strObj)
            %loadobj Implements loading of message from MAT file
            
            % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = robotics.ros.custom.msggen.moveit_msgs.PlanningScene.empty(0,1);
                return
            end
            
            % Create an empty message object
            obj = robotics.ros.custom.msggen.moveit_msgs.PlanningScene;
            obj.reload(strObj);
        end
    end
end
