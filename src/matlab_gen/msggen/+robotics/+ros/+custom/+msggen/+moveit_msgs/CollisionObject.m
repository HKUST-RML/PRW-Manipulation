classdef CollisionObject < robotics.ros.Message
    %CollisionObject MATLAB implementation of moveit_msgs/CollisionObject
    %   This class was automatically generated by
    %   robotics.ros.msg.internal.gen.MessageClassGenerator.
    
    %   Copyright 2014-2018 The MathWorks, Inc.
    
    %#ok<*INUSD>
    
    properties (Constant)
        MessageType = 'moveit_msgs/CollisionObject' % The ROS message type
    end
    
    properties (Constant, Hidden)
        MD5Checksum = '568a161b26dc46c54a5a07621ce82cf3' % The MD5 Checksum of the message definition
    end
    
    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    properties (Constant)
        ADD = uint8(0)
        REMOVE = uint8(1)
        APPEND = uint8(2)
        MOVE = uint8(3)
    end
    
    properties (Constant, Access = protected)
        GeometryMsgsPoseClass = robotics.ros.msg.internal.MessageFactory.getClassForType('geometry_msgs/Pose') % Dispatch to MATLAB class for message type geometry_msgs/Pose
        ObjectRecognitionMsgsObjectTypeClass = robotics.ros.msg.internal.MessageFactory.getClassForType('object_recognition_msgs/ObjectType') % Dispatch to MATLAB class for message type object_recognition_msgs/ObjectType
        ShapeMsgsMeshClass = robotics.ros.msg.internal.MessageFactory.getClassForType('shape_msgs/Mesh') % Dispatch to MATLAB class for message type shape_msgs/Mesh
        ShapeMsgsPlaneClass = robotics.ros.msg.internal.MessageFactory.getClassForType('shape_msgs/Plane') % Dispatch to MATLAB class for message type shape_msgs/Plane
        ShapeMsgsSolidPrimitiveClass = robotics.ros.msg.internal.MessageFactory.getClassForType('shape_msgs/SolidPrimitive') % Dispatch to MATLAB class for message type shape_msgs/SolidPrimitive
        StdMsgsHeaderClass = robotics.ros.msg.internal.MessageFactory.getClassForType('std_msgs/Header') % Dispatch to MATLAB class for message type std_msgs/Header
    end
    
    properties (Dependent)
        Header
        Id
        Type
        Operation
        Primitives
        PrimitivePoses
        Meshes
        MeshPoses
        Planes
        PlanePoses
    end
    
    properties (Access = protected)
        Cache = struct('Header', [], 'Type', [], 'Primitives', [], 'PrimitivePoses', [], 'Meshes', [], 'MeshPoses', [], 'Planes', [], 'PlanePoses', []) % The cache for fast data access
    end
    
    properties (Constant, Hidden)
        PropertyList = {'Header', 'Id', 'MeshPoses', 'Meshes', 'Operation', 'PlanePoses', 'Planes', 'PrimitivePoses', 'Primitives', 'Type'} % List of non-constant message properties
        ROSPropertyList = {'header', 'id', 'mesh_poses', 'meshes', 'operation', 'plane_poses', 'planes', 'primitive_poses', 'primitives', 'type'} % List of non-constant ROS message properties
    end
    
    methods
        function obj = CollisionObject(msg)
            %CollisionObject Construct the message object CollisionObject
            import com.mathworks.toolbox.robotics.ros.message.MessageInfo;
            
            % Support default constructor
            if nargin == 0
                obj.JavaMessage = obj.createNewJavaMessage;
                return;
            end
            
            % Construct appropriate empty array
            if isempty(msg)
                obj = obj.empty(0,1);
                return;
            end
            
            % Make scalar construction fast
            if isscalar(msg)
                % Check for correct input class
                if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
                    error(message('robotics:ros:message:NoTypeMatch', obj.MessageType, ...
                        char(MessageInfo.getType(msg(1))) ));
                end
                obj.JavaMessage = msg(1);
                return;
            end
            
            % Check that this is a vector of scalar messages. Since this
            % is an object array, use arrayfun to verify.
            if ~all(arrayfun(@isscalar, msg))
                error(message('robotics:ros:message:MessageArraySizeError'));
            end
            
            % Check that all messages in the array have the correct type
            if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
                error(message('robotics:ros:message:NoTypeMatchArray', obj.MessageType));
            end
            
            % Construct array of objects if necessary
            objType = class(obj);
            for i = 1:length(msg)
                obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
            end
        end
        
        function header = get.Header(obj)
            %get.Header Get the value for property Header
            if isempty(obj.Cache.Header)
                obj.Cache.Header = feval(obj.StdMsgsHeaderClass, obj.JavaMessage.getHeader);
            end
            header = obj.Cache.Header;
        end
        
        function set.Header(obj, header)
            %set.Header Set the value for property Header
            validateattributes(header, {obj.StdMsgsHeaderClass}, {'nonempty', 'scalar'}, 'CollisionObject', 'Header');
            
            obj.JavaMessage.setHeader(header.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.Header)
                obj.Cache.Header.setJavaObject(header.getJavaObject);
            end
        end
        
        function id = get.Id(obj)
            %get.Id Get the value for property Id
            id = char(obj.JavaMessage.getId);
        end
        
        function set.Id(obj, id)
            %set.Id Set the value for property Id
            validateattributes(id, {'char'}, {}, 'CollisionObject', 'Id');
            
            obj.JavaMessage.setId(id);
        end
        
        function type = get.Type(obj)
            %get.Type Get the value for property Type
            if isempty(obj.Cache.Type)
                obj.Cache.Type = feval(obj.ObjectRecognitionMsgsObjectTypeClass, obj.JavaMessage.getType);
            end
            type = obj.Cache.Type;
        end
        
        function set.Type(obj, type)
            %set.Type Set the value for property Type
            validateattributes(type, {obj.ObjectRecognitionMsgsObjectTypeClass}, {'nonempty', 'scalar'}, 'CollisionObject', 'Type');
            
            obj.JavaMessage.setType(type.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.Type)
                obj.Cache.Type.setJavaObject(type.getJavaObject);
            end
        end
        
        function operation = get.Operation(obj)
            %get.Operation Get the value for property Operation
            operation = typecast(int8(obj.JavaMessage.getOperation), 'uint8');
        end
        
        function set.Operation(obj, operation)
            %set.Operation Set the value for property Operation
            validateattributes(operation, {'numeric'}, {'nonempty', 'scalar'}, 'CollisionObject', 'Operation');
            
            obj.JavaMessage.setOperation(operation);
        end
        
        function primitives = get.Primitives(obj)
            %get.Primitives Get the value for property Primitives
            if isempty(obj.Cache.Primitives)
                javaArray = obj.JavaMessage.getPrimitives;
                array = obj.readJavaArray(javaArray, obj.ShapeMsgsSolidPrimitiveClass);
                obj.Cache.Primitives = feval(obj.ShapeMsgsSolidPrimitiveClass, array);
            end
            primitives = obj.Cache.Primitives;
        end
        
        function set.Primitives(obj, primitives)
            %set.Primitives Set the value for property Primitives
            if ~isvector(primitives) && isempty(primitives)
                % Allow empty [] input
                primitives = feval([obj.ShapeMsgsSolidPrimitiveClass '.empty'], 0, 1);
            end
            
            validateattributes(primitives, {obj.ShapeMsgsSolidPrimitiveClass}, {'vector'}, 'CollisionObject', 'Primitives');
            
            javaArray = obj.JavaMessage.getPrimitives;
            array = obj.writeJavaArray(primitives, javaArray, obj.ShapeMsgsSolidPrimitiveClass);
            obj.JavaMessage.setPrimitives(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.Primitives)
                obj.Cache.Primitives = [];
                obj.Cache.Primitives = obj.Primitives;
            end
        end
        
        function primitiveposes = get.PrimitivePoses(obj)
            %get.PrimitivePoses Get the value for property PrimitivePoses
            if isempty(obj.Cache.PrimitivePoses)
                javaArray = obj.JavaMessage.getPrimitivePoses;
                array = obj.readJavaArray(javaArray, obj.GeometryMsgsPoseClass);
                obj.Cache.PrimitivePoses = feval(obj.GeometryMsgsPoseClass, array);
            end
            primitiveposes = obj.Cache.PrimitivePoses;
        end
        
        function set.PrimitivePoses(obj, primitiveposes)
            %set.PrimitivePoses Set the value for property PrimitivePoses
            if ~isvector(primitiveposes) && isempty(primitiveposes)
                % Allow empty [] input
                primitiveposes = feval([obj.GeometryMsgsPoseClass '.empty'], 0, 1);
            end
            
            validateattributes(primitiveposes, {obj.GeometryMsgsPoseClass}, {'vector'}, 'CollisionObject', 'PrimitivePoses');
            
            javaArray = obj.JavaMessage.getPrimitivePoses;
            array = obj.writeJavaArray(primitiveposes, javaArray, obj.GeometryMsgsPoseClass);
            obj.JavaMessage.setPrimitivePoses(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PrimitivePoses)
                obj.Cache.PrimitivePoses = [];
                obj.Cache.PrimitivePoses = obj.PrimitivePoses;
            end
        end
        
        function meshes = get.Meshes(obj)
            %get.Meshes Get the value for property Meshes
            if isempty(obj.Cache.Meshes)
                javaArray = obj.JavaMessage.getMeshes;
                array = obj.readJavaArray(javaArray, obj.ShapeMsgsMeshClass);
                obj.Cache.Meshes = feval(obj.ShapeMsgsMeshClass, array);
            end
            meshes = obj.Cache.Meshes;
        end
        
        function set.Meshes(obj, meshes)
            %set.Meshes Set the value for property Meshes
            if ~isvector(meshes) && isempty(meshes)
                % Allow empty [] input
                meshes = feval([obj.ShapeMsgsMeshClass '.empty'], 0, 1);
            end
            
            validateattributes(meshes, {obj.ShapeMsgsMeshClass}, {'vector'}, 'CollisionObject', 'Meshes');
            
            javaArray = obj.JavaMessage.getMeshes;
            array = obj.writeJavaArray(meshes, javaArray, obj.ShapeMsgsMeshClass);
            obj.JavaMessage.setMeshes(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.Meshes)
                obj.Cache.Meshes = [];
                obj.Cache.Meshes = obj.Meshes;
            end
        end
        
        function meshposes = get.MeshPoses(obj)
            %get.MeshPoses Get the value for property MeshPoses
            if isempty(obj.Cache.MeshPoses)
                javaArray = obj.JavaMessage.getMeshPoses;
                array = obj.readJavaArray(javaArray, obj.GeometryMsgsPoseClass);
                obj.Cache.MeshPoses = feval(obj.GeometryMsgsPoseClass, array);
            end
            meshposes = obj.Cache.MeshPoses;
        end
        
        function set.MeshPoses(obj, meshposes)
            %set.MeshPoses Set the value for property MeshPoses
            if ~isvector(meshposes) && isempty(meshposes)
                % Allow empty [] input
                meshposes = feval([obj.GeometryMsgsPoseClass '.empty'], 0, 1);
            end
            
            validateattributes(meshposes, {obj.GeometryMsgsPoseClass}, {'vector'}, 'CollisionObject', 'MeshPoses');
            
            javaArray = obj.JavaMessage.getMeshPoses;
            array = obj.writeJavaArray(meshposes, javaArray, obj.GeometryMsgsPoseClass);
            obj.JavaMessage.setMeshPoses(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.MeshPoses)
                obj.Cache.MeshPoses = [];
                obj.Cache.MeshPoses = obj.MeshPoses;
            end
        end
        
        function planes = get.Planes(obj)
            %get.Planes Get the value for property Planes
            if isempty(obj.Cache.Planes)
                javaArray = obj.JavaMessage.getPlanes;
                array = obj.readJavaArray(javaArray, obj.ShapeMsgsPlaneClass);
                obj.Cache.Planes = feval(obj.ShapeMsgsPlaneClass, array);
            end
            planes = obj.Cache.Planes;
        end
        
        function set.Planes(obj, planes)
            %set.Planes Set the value for property Planes
            if ~isvector(planes) && isempty(planes)
                % Allow empty [] input
                planes = feval([obj.ShapeMsgsPlaneClass '.empty'], 0, 1);
            end
            
            validateattributes(planes, {obj.ShapeMsgsPlaneClass}, {'vector'}, 'CollisionObject', 'Planes');
            
            javaArray = obj.JavaMessage.getPlanes;
            array = obj.writeJavaArray(planes, javaArray, obj.ShapeMsgsPlaneClass);
            obj.JavaMessage.setPlanes(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.Planes)
                obj.Cache.Planes = [];
                obj.Cache.Planes = obj.Planes;
            end
        end
        
        function planeposes = get.PlanePoses(obj)
            %get.PlanePoses Get the value for property PlanePoses
            if isempty(obj.Cache.PlanePoses)
                javaArray = obj.JavaMessage.getPlanePoses;
                array = obj.readJavaArray(javaArray, obj.GeometryMsgsPoseClass);
                obj.Cache.PlanePoses = feval(obj.GeometryMsgsPoseClass, array);
            end
            planeposes = obj.Cache.PlanePoses;
        end
        
        function set.PlanePoses(obj, planeposes)
            %set.PlanePoses Set the value for property PlanePoses
            if ~isvector(planeposes) && isempty(planeposes)
                % Allow empty [] input
                planeposes = feval([obj.GeometryMsgsPoseClass '.empty'], 0, 1);
            end
            
            validateattributes(planeposes, {obj.GeometryMsgsPoseClass}, {'vector'}, 'CollisionObject', 'PlanePoses');
            
            javaArray = obj.JavaMessage.getPlanePoses;
            array = obj.writeJavaArray(planeposes, javaArray, obj.GeometryMsgsPoseClass);
            obj.JavaMessage.setPlanePoses(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PlanePoses)
                obj.Cache.PlanePoses = [];
                obj.Cache.PlanePoses = obj.PlanePoses;
            end
        end
    end
    
    methods (Access = protected)
        function resetCache(obj)
            %resetCache Resets any cached properties
            obj.Cache.Header = [];
            obj.Cache.Type = [];
            obj.Cache.Primitives = [];
            obj.Cache.PrimitivePoses = [];
            obj.Cache.Meshes = [];
            obj.Cache.MeshPoses = [];
            obj.Cache.Planes = [];
            obj.Cache.PlanePoses = [];
        end
        
        function cpObj = copyElement(obj)
            %copyElement Implements deep copy behavior for message
            
            % Call default copy method for shallow copy
            cpObj = copyElement@robotics.ros.Message(obj);
            
            % Clear any existing cached properties
            cpObj.resetCache;
            
            % Create a new Java message object
            cpObj.JavaMessage = obj.createNewJavaMessage;
            
            % Iterate over all primitive properties
            cpObj.Id = obj.Id;
            cpObj.Operation = obj.Operation;
            
            % Recursively copy compound properties
            cpObj.Header = copy(obj.Header);
            cpObj.Type = copy(obj.Type);
            cpObj.Primitives = copy(obj.Primitives);
            cpObj.PrimitivePoses = copy(obj.PrimitivePoses);
            cpObj.Meshes = copy(obj.Meshes);
            cpObj.MeshPoses = copy(obj.MeshPoses);
            cpObj.Planes = copy(obj.Planes);
            cpObj.PlanePoses = copy(obj.PlanePoses);
        end
        
        function reload(obj, strObj)
            %reload Called by loadobj to assign properties
            obj.Id = strObj.Id;
            obj.Operation = strObj.Operation;
            obj.Header = feval([obj.StdMsgsHeaderClass '.loadobj'], strObj.Header);
            obj.Type = feval([obj.ObjectRecognitionMsgsObjectTypeClass '.loadobj'], strObj.Type);
            PrimitivesCell = arrayfun(@(x) feval([obj.ShapeMsgsSolidPrimitiveClass '.loadobj'], x), strObj.Primitives, 'UniformOutput', false);
            obj.Primitives = vertcat(PrimitivesCell{:});
            PrimitivePosesCell = arrayfun(@(x) feval([obj.GeometryMsgsPoseClass '.loadobj'], x), strObj.PrimitivePoses, 'UniformOutput', false);
            obj.PrimitivePoses = vertcat(PrimitivePosesCell{:});
            MeshesCell = arrayfun(@(x) feval([obj.ShapeMsgsMeshClass '.loadobj'], x), strObj.Meshes, 'UniformOutput', false);
            obj.Meshes = vertcat(MeshesCell{:});
            MeshPosesCell = arrayfun(@(x) feval([obj.GeometryMsgsPoseClass '.loadobj'], x), strObj.MeshPoses, 'UniformOutput', false);
            obj.MeshPoses = vertcat(MeshPosesCell{:});
            PlanesCell = arrayfun(@(x) feval([obj.ShapeMsgsPlaneClass '.loadobj'], x), strObj.Planes, 'UniformOutput', false);
            obj.Planes = vertcat(PlanesCell{:});
            PlanePosesCell = arrayfun(@(x) feval([obj.GeometryMsgsPoseClass '.loadobj'], x), strObj.PlanePoses, 'UniformOutput', false);
            obj.PlanePoses = vertcat(PlanePosesCell{:});
        end
    end
    
    methods (Access = ?robotics.ros.Message)
        function strObj = saveobj(obj)
            %saveobj Implements saving of message to MAT file
            
            % Return an empty element if object array is empty
            if isempty(obj)
                strObj = struct.empty;
                return
            end
            
            strObj.Id = obj.Id;
            strObj.Operation = obj.Operation;
            strObj.Header = saveobj(obj.Header);
            strObj.Type = saveobj(obj.Type);
            strObj.Primitives = arrayfun(@(x) saveobj(x), obj.Primitives);
            strObj.PrimitivePoses = arrayfun(@(x) saveobj(x), obj.PrimitivePoses);
            strObj.Meshes = arrayfun(@(x) saveobj(x), obj.Meshes);
            strObj.MeshPoses = arrayfun(@(x) saveobj(x), obj.MeshPoses);
            strObj.Planes = arrayfun(@(x) saveobj(x), obj.Planes);
            strObj.PlanePoses = arrayfun(@(x) saveobj(x), obj.PlanePoses);
        end
    end
    
    methods (Static, Access = {?matlab.unittest.TestCase, ?robotics.ros.Message})
        function obj = loadobj(strObj)
            %loadobj Implements loading of message from MAT file
            
            % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = robotics.ros.custom.msggen.moveit_msgs.CollisionObject.empty(0,1);
                return
            end
            
            % Create an empty message object
            obj = robotics.ros.custom.msggen.moveit_msgs.CollisionObject;
            obj.reload(strObj);
        end
    end
end
