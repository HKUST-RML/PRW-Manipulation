classdef PlaceGoal < robotics.ros.Message
    %PlaceGoal MATLAB implementation of moveit_msgs/PlaceGoal
    %   This class was automatically generated by
    %   robotics.ros.msg.internal.gen.MessageClassGenerator.
    
    %   Copyright 2014-2018 The MathWorks, Inc.
    
    %#ok<*INUSD>
    
    properties (Constant)
        MessageType = 'moveit_msgs/PlaceGoal' % The ROS message type
    end
    
    properties (Constant, Hidden)
        MD5Checksum = 'e3f3e956e536ccd313fd8f23023f0a94' % The MD5 Checksum of the message definition
    end
    
    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    properties (Constant, Access = protected)
        MoveitMsgsConstraintsClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/Constraints') % Dispatch to MATLAB class for message type moveit_msgs/Constraints
        MoveitMsgsPlaceLocationClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/PlaceLocation') % Dispatch to MATLAB class for message type moveit_msgs/PlaceLocation
        MoveitMsgsPlanningOptionsClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/PlanningOptions') % Dispatch to MATLAB class for message type moveit_msgs/PlanningOptions
    end
    
    properties (Dependent)
        GroupName
        AttachedObjectName
        PlaceEef
        SupportSurfaceName
        AllowGripperSupportCollision
        PathConstraints
        PlannerId
        AllowedPlanningTime
        PlanningOptions
        PlaceLocations
        AllowedTouchObjects
    end
    
    properties (Access = protected)
        Cache = struct('PlaceLocations', [], 'PathConstraints', [], 'PlanningOptions', []) % The cache for fast data access
    end
    
    properties (Constant, Hidden)
        PropertyList = {'AllowGripperSupportCollision', 'AllowedPlanningTime', 'AllowedTouchObjects', 'AttachedObjectName', 'GroupName', 'PathConstraints', 'PlaceEef', 'PlaceLocations', 'PlannerId', 'PlanningOptions', 'SupportSurfaceName'} % List of non-constant message properties
        ROSPropertyList = {'allow_gripper_support_collision', 'allowed_planning_time', 'allowed_touch_objects', 'attached_object_name', 'group_name', 'path_constraints', 'place_eef', 'place_locations', 'planner_id', 'planning_options', 'support_surface_name'} % List of non-constant ROS message properties
    end
    
    methods
        function obj = PlaceGoal(msg)
            %PlaceGoal Construct the message object PlaceGoal
            import com.mathworks.toolbox.robotics.ros.message.MessageInfo;
            
            % Support default constructor
            if nargin == 0
                obj.JavaMessage = obj.createNewJavaMessage;
                return;
            end
            
            % Construct appropriate empty array
            if isempty(msg)
                obj = obj.empty(0,1);
                return;
            end
            
            % Make scalar construction fast
            if isscalar(msg)
                % Check for correct input class
                if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
                    error(message('robotics:ros:message:NoTypeMatch', obj.MessageType, ...
                        char(MessageInfo.getType(msg(1))) ));
                end
                obj.JavaMessage = msg(1);
                return;
            end
            
            % Check that this is a vector of scalar messages. Since this
            % is an object array, use arrayfun to verify.
            if ~all(arrayfun(@isscalar, msg))
                error(message('robotics:ros:message:MessageArraySizeError'));
            end
            
            % Check that all messages in the array have the correct type
            if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
                error(message('robotics:ros:message:NoTypeMatchArray', obj.MessageType));
            end
            
            % Construct array of objects if necessary
            objType = class(obj);
            for i = 1:length(msg)
                obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
            end
        end
        
        function groupname = get.GroupName(obj)
            %get.GroupName Get the value for property GroupName
            groupname = char(obj.JavaMessage.getGroupName);
        end
        
        function set.GroupName(obj, groupname)
            %set.GroupName Set the value for property GroupName
            validateattributes(groupname, {'char'}, {}, 'PlaceGoal', 'GroupName');
            
            obj.JavaMessage.setGroupName(groupname);
        end
        
        function attachedobjectname = get.AttachedObjectName(obj)
            %get.AttachedObjectName Get the value for property AttachedObjectName
            attachedobjectname = char(obj.JavaMessage.getAttachedObjectName);
        end
        
        function set.AttachedObjectName(obj, attachedobjectname)
            %set.AttachedObjectName Set the value for property AttachedObjectName
            validateattributes(attachedobjectname, {'char'}, {}, 'PlaceGoal', 'AttachedObjectName');
            
            obj.JavaMessage.setAttachedObjectName(attachedobjectname);
        end
        
        function placeeef = get.PlaceEef(obj)
            %get.PlaceEef Get the value for property PlaceEef
            placeeef = logical(obj.JavaMessage.getPlaceEef);
        end
        
        function set.PlaceEef(obj, placeeef)
            %set.PlaceEef Set the value for property PlaceEef
            validateattributes(placeeef, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'PlaceGoal', 'PlaceEef');
            
            obj.JavaMessage.setPlaceEef(placeeef);
        end
        
        function supportsurfacename = get.SupportSurfaceName(obj)
            %get.SupportSurfaceName Get the value for property SupportSurfaceName
            supportsurfacename = char(obj.JavaMessage.getSupportSurfaceName);
        end
        
        function set.SupportSurfaceName(obj, supportsurfacename)
            %set.SupportSurfaceName Set the value for property SupportSurfaceName
            validateattributes(supportsurfacename, {'char'}, {}, 'PlaceGoal', 'SupportSurfaceName');
            
            obj.JavaMessage.setSupportSurfaceName(supportsurfacename);
        end
        
        function allowgrippersupportcollision = get.AllowGripperSupportCollision(obj)
            %get.AllowGripperSupportCollision Get the value for property AllowGripperSupportCollision
            allowgrippersupportcollision = logical(obj.JavaMessage.getAllowGripperSupportCollision);
        end
        
        function set.AllowGripperSupportCollision(obj, allowgrippersupportcollision)
            %set.AllowGripperSupportCollision Set the value for property AllowGripperSupportCollision
            validateattributes(allowgrippersupportcollision, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'PlaceGoal', 'AllowGripperSupportCollision');
            
            obj.JavaMessage.setAllowGripperSupportCollision(allowgrippersupportcollision);
        end
        
        function pathconstraints = get.PathConstraints(obj)
            %get.PathConstraints Get the value for property PathConstraints
            if isempty(obj.Cache.PathConstraints)
                obj.Cache.PathConstraints = feval(obj.MoveitMsgsConstraintsClass, obj.JavaMessage.getPathConstraints);
            end
            pathconstraints = obj.Cache.PathConstraints;
        end
        
        function set.PathConstraints(obj, pathconstraints)
            %set.PathConstraints Set the value for property PathConstraints
            validateattributes(pathconstraints, {obj.MoveitMsgsConstraintsClass}, {'nonempty', 'scalar'}, 'PlaceGoal', 'PathConstraints');
            
            obj.JavaMessage.setPathConstraints(pathconstraints.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PathConstraints)
                obj.Cache.PathConstraints.setJavaObject(pathconstraints.getJavaObject);
            end
        end
        
        function plannerid = get.PlannerId(obj)
            %get.PlannerId Get the value for property PlannerId
            plannerid = char(obj.JavaMessage.getPlannerId);
        end
        
        function set.PlannerId(obj, plannerid)
            %set.PlannerId Set the value for property PlannerId
            validateattributes(plannerid, {'char'}, {}, 'PlaceGoal', 'PlannerId');
            
            obj.JavaMessage.setPlannerId(plannerid);
        end
        
        function allowedplanningtime = get.AllowedPlanningTime(obj)
            %get.AllowedPlanningTime Get the value for property AllowedPlanningTime
            allowedplanningtime = double(obj.JavaMessage.getAllowedPlanningTime);
        end
        
        function set.AllowedPlanningTime(obj, allowedplanningtime)
            %set.AllowedPlanningTime Set the value for property AllowedPlanningTime
            validateattributes(allowedplanningtime, {'numeric'}, {'nonempty', 'scalar'}, 'PlaceGoal', 'AllowedPlanningTime');
            
            obj.JavaMessage.setAllowedPlanningTime(allowedplanningtime);
        end
        
        function planningoptions = get.PlanningOptions(obj)
            %get.PlanningOptions Get the value for property PlanningOptions
            if isempty(obj.Cache.PlanningOptions)
                obj.Cache.PlanningOptions = feval(obj.MoveitMsgsPlanningOptionsClass, obj.JavaMessage.getPlanningOptions);
            end
            planningoptions = obj.Cache.PlanningOptions;
        end
        
        function set.PlanningOptions(obj, planningoptions)
            %set.PlanningOptions Set the value for property PlanningOptions
            validateattributes(planningoptions, {obj.MoveitMsgsPlanningOptionsClass}, {'nonempty', 'scalar'}, 'PlaceGoal', 'PlanningOptions');
            
            obj.JavaMessage.setPlanningOptions(planningoptions.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PlanningOptions)
                obj.Cache.PlanningOptions.setJavaObject(planningoptions.getJavaObject);
            end
        end
        
        function placelocations = get.PlaceLocations(obj)
            %get.PlaceLocations Get the value for property PlaceLocations
            if isempty(obj.Cache.PlaceLocations)
                javaArray = obj.JavaMessage.getPlaceLocations;
                array = obj.readJavaArray(javaArray, obj.MoveitMsgsPlaceLocationClass);
                obj.Cache.PlaceLocations = feval(obj.MoveitMsgsPlaceLocationClass, array);
            end
            placelocations = obj.Cache.PlaceLocations;
        end
        
        function set.PlaceLocations(obj, placelocations)
            %set.PlaceLocations Set the value for property PlaceLocations
            if ~isvector(placelocations) && isempty(placelocations)
                % Allow empty [] input
                placelocations = feval([obj.MoveitMsgsPlaceLocationClass '.empty'], 0, 1);
            end
            
            validateattributes(placelocations, {obj.MoveitMsgsPlaceLocationClass}, {'vector'}, 'PlaceGoal', 'PlaceLocations');
            
            javaArray = obj.JavaMessage.getPlaceLocations;
            array = obj.writeJavaArray(placelocations, javaArray, obj.MoveitMsgsPlaceLocationClass);
            obj.JavaMessage.setPlaceLocations(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PlaceLocations)
                obj.Cache.PlaceLocations = [];
                obj.Cache.PlaceLocations = obj.PlaceLocations;
            end
        end
        
        function allowedtouchobjects = get.AllowedTouchObjects(obj)
            %get.AllowedTouchObjects Get the value for property AllowedTouchObjects
            javaArray = obj.JavaMessage.getAllowedTouchObjects;
            array = obj.readJavaArray(javaArray, 'char');
            allowedtouchobjects = arrayfun(@(x) char(x), array, 'UniformOutput', false);
        end
        
        function set.AllowedTouchObjects(obj, allowedtouchobjects)
            %set.AllowedTouchObjects Set the value for property AllowedTouchObjects
            if ~isvector(allowedtouchobjects) && isempty(allowedtouchobjects)
                % Allow empty [] input
                allowedtouchobjects = cell.empty(0,1);
            end
            
            validateattributes(allowedtouchobjects, {'cell'}, {'vector'}, 'PlaceGoal', 'AllowedTouchObjects');
            if any(cellfun(@(x) ~ischar(x), allowedtouchobjects))
                error(message('robotics:ros:message:CellArrayStringError', ...
                    'allowedtouchobjects'));
            end
            
            javaArray = obj.JavaMessage.getAllowedTouchObjects;
            array = obj.writeJavaArray(allowedtouchobjects, javaArray, 'char');
            obj.JavaMessage.setAllowedTouchObjects(array);
        end
    end
    
    methods (Access = protected)
        function resetCache(obj)
            %resetCache Resets any cached properties
            obj.Cache.PlaceLocations = [];
            obj.Cache.PathConstraints = [];
            obj.Cache.PlanningOptions = [];
        end
        
        function cpObj = copyElement(obj)
            %copyElement Implements deep copy behavior for message
            
            % Call default copy method for shallow copy
            cpObj = copyElement@robotics.ros.Message(obj);
            
            % Clear any existing cached properties
            cpObj.resetCache;
            
            % Create a new Java message object
            cpObj.JavaMessage = obj.createNewJavaMessage;
            
            % Iterate over all primitive properties
            cpObj.GroupName = obj.GroupName;
            cpObj.AttachedObjectName = obj.AttachedObjectName;
            cpObj.PlaceEef = obj.PlaceEef;
            cpObj.SupportSurfaceName = obj.SupportSurfaceName;
            cpObj.AllowGripperSupportCollision = obj.AllowGripperSupportCollision;
            cpObj.PlannerId = obj.PlannerId;
            cpObj.AllowedPlanningTime = obj.AllowedPlanningTime;
            cpObj.AllowedTouchObjects = obj.AllowedTouchObjects;
            
            % Recursively copy compound properties
            cpObj.PathConstraints = copy(obj.PathConstraints);
            cpObj.PlanningOptions = copy(obj.PlanningOptions);
            cpObj.PlaceLocations = copy(obj.PlaceLocations);
        end
        
        function reload(obj, strObj)
            %reload Called by loadobj to assign properties
            obj.GroupName = strObj.GroupName;
            obj.AttachedObjectName = strObj.AttachedObjectName;
            obj.PlaceEef = strObj.PlaceEef;
            obj.SupportSurfaceName = strObj.SupportSurfaceName;
            obj.AllowGripperSupportCollision = strObj.AllowGripperSupportCollision;
            obj.PlannerId = strObj.PlannerId;
            obj.AllowedPlanningTime = strObj.AllowedPlanningTime;
            obj.AllowedTouchObjects = strObj.AllowedTouchObjects;
            obj.PathConstraints = feval([obj.MoveitMsgsConstraintsClass '.loadobj'], strObj.PathConstraints);
            obj.PlanningOptions = feval([obj.MoveitMsgsPlanningOptionsClass '.loadobj'], strObj.PlanningOptions);
            PlaceLocationsCell = arrayfun(@(x) feval([obj.MoveitMsgsPlaceLocationClass '.loadobj'], x), strObj.PlaceLocations, 'UniformOutput', false);
            obj.PlaceLocations = vertcat(PlaceLocationsCell{:});
        end
    end
    
    methods (Access = ?robotics.ros.Message)
        function strObj = saveobj(obj)
            %saveobj Implements saving of message to MAT file
            
            % Return an empty element if object array is empty
            if isempty(obj)
                strObj = struct.empty;
                return
            end
            
            strObj.GroupName = obj.GroupName;
            strObj.AttachedObjectName = obj.AttachedObjectName;
            strObj.PlaceEef = obj.PlaceEef;
            strObj.SupportSurfaceName = obj.SupportSurfaceName;
            strObj.AllowGripperSupportCollision = obj.AllowGripperSupportCollision;
            strObj.PlannerId = obj.PlannerId;
            strObj.AllowedPlanningTime = obj.AllowedPlanningTime;
            strObj.AllowedTouchObjects = obj.AllowedTouchObjects;
            strObj.PathConstraints = saveobj(obj.PathConstraints);
            strObj.PlanningOptions = saveobj(obj.PlanningOptions);
            strObj.PlaceLocations = arrayfun(@(x) saveobj(x), obj.PlaceLocations);
        end
    end
    
    methods (Static, Access = {?matlab.unittest.TestCase, ?robotics.ros.Message})
        function obj = loadobj(strObj)
            %loadobj Implements loading of message from MAT file
            
            % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = robotics.ros.custom.msggen.moveit_msgs.PlaceGoal.empty(0,1);
                return
            end
            
            % Create an empty message object
            obj = robotics.ros.custom.msggen.moveit_msgs.PlaceGoal;
            obj.reload(strObj);
        end
    end
end
