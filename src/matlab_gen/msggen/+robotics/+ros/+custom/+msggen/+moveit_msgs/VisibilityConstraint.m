classdef VisibilityConstraint < robotics.ros.Message
    %VisibilityConstraint MATLAB implementation of moveit_msgs/VisibilityConstraint
    %   This class was automatically generated by
    %   robotics.ros.msg.internal.gen.MessageClassGenerator.
    
    %   Copyright 2014-2018 The MathWorks, Inc.
    
    %#ok<*INUSD>
    
    properties (Constant)
        MessageType = 'moveit_msgs/VisibilityConstraint' % The ROS message type
    end
    
    properties (Constant, Hidden)
        MD5Checksum = '62cda903bfe31ff2e5fcdc3810d577ad' % The MD5 Checksum of the message definition
    end
    
    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    properties (Constant)
        SENSORZ = uint8(0)
        SENSORY = uint8(1)
        SENSORX = uint8(2)
    end
    
    properties (Constant, Access = protected)
        GeometryMsgsPoseStampedClass = robotics.ros.msg.internal.MessageFactory.getClassForType('geometry_msgs/PoseStamped') % Dispatch to MATLAB class for message type geometry_msgs/PoseStamped
    end
    
    properties (Dependent)
        TargetRadius
        TargetPose
        ConeSides
        SensorPose
        MaxViewAngle
        MaxRangeAngle
        SensorViewDirection
        Weight
    end
    
    properties (Access = protected)
        Cache = struct('TargetPose', [], 'SensorPose', []) % The cache for fast data access
    end
    
    properties (Constant, Hidden)
        PropertyList = {'ConeSides', 'MaxRangeAngle', 'MaxViewAngle', 'SensorPose', 'SensorViewDirection', 'TargetPose', 'TargetRadius', 'Weight'} % List of non-constant message properties
        ROSPropertyList = {'cone_sides', 'max_range_angle', 'max_view_angle', 'sensor_pose', 'sensor_view_direction', 'target_pose', 'target_radius', 'weight'} % List of non-constant ROS message properties
    end
    
    methods
        function obj = VisibilityConstraint(msg)
            %VisibilityConstraint Construct the message object VisibilityConstraint
            import com.mathworks.toolbox.robotics.ros.message.MessageInfo;
            
            % Support default constructor
            if nargin == 0
                obj.JavaMessage = obj.createNewJavaMessage;
                return;
            end
            
            % Construct appropriate empty array
            if isempty(msg)
                obj = obj.empty(0,1);
                return;
            end
            
            % Make scalar construction fast
            if isscalar(msg)
                % Check for correct input class
                if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
                    error(message('robotics:ros:message:NoTypeMatch', obj.MessageType, ...
                        char(MessageInfo.getType(msg(1))) ));
                end
                obj.JavaMessage = msg(1);
                return;
            end
            
            % Check that this is a vector of scalar messages. Since this
            % is an object array, use arrayfun to verify.
            if ~all(arrayfun(@isscalar, msg))
                error(message('robotics:ros:message:MessageArraySizeError'));
            end
            
            % Check that all messages in the array have the correct type
            if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
                error(message('robotics:ros:message:NoTypeMatchArray', obj.MessageType));
            end
            
            % Construct array of objects if necessary
            objType = class(obj);
            for i = 1:length(msg)
                obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
            end
        end
        
        function targetradius = get.TargetRadius(obj)
            %get.TargetRadius Get the value for property TargetRadius
            targetradius = double(obj.JavaMessage.getTargetRadius);
        end
        
        function set.TargetRadius(obj, targetradius)
            %set.TargetRadius Set the value for property TargetRadius
            validateattributes(targetradius, {'numeric'}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'TargetRadius');
            
            obj.JavaMessage.setTargetRadius(targetradius);
        end
        
        function targetpose = get.TargetPose(obj)
            %get.TargetPose Get the value for property TargetPose
            if isempty(obj.Cache.TargetPose)
                obj.Cache.TargetPose = feval(obj.GeometryMsgsPoseStampedClass, obj.JavaMessage.getTargetPose);
            end
            targetpose = obj.Cache.TargetPose;
        end
        
        function set.TargetPose(obj, targetpose)
            %set.TargetPose Set the value for property TargetPose
            validateattributes(targetpose, {obj.GeometryMsgsPoseStampedClass}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'TargetPose');
            
            obj.JavaMessage.setTargetPose(targetpose.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.TargetPose)
                obj.Cache.TargetPose.setJavaObject(targetpose.getJavaObject);
            end
        end
        
        function conesides = get.ConeSides(obj)
            %get.ConeSides Get the value for property ConeSides
            conesides = int32(obj.JavaMessage.getConeSides);
        end
        
        function set.ConeSides(obj, conesides)
            %set.ConeSides Set the value for property ConeSides
            validateattributes(conesides, {'numeric'}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'ConeSides');
            
            obj.JavaMessage.setConeSides(conesides);
        end
        
        function sensorpose = get.SensorPose(obj)
            %get.SensorPose Get the value for property SensorPose
            if isempty(obj.Cache.SensorPose)
                obj.Cache.SensorPose = feval(obj.GeometryMsgsPoseStampedClass, obj.JavaMessage.getSensorPose);
            end
            sensorpose = obj.Cache.SensorPose;
        end
        
        function set.SensorPose(obj, sensorpose)
            %set.SensorPose Set the value for property SensorPose
            validateattributes(sensorpose, {obj.GeometryMsgsPoseStampedClass}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'SensorPose');
            
            obj.JavaMessage.setSensorPose(sensorpose.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.SensorPose)
                obj.Cache.SensorPose.setJavaObject(sensorpose.getJavaObject);
            end
        end
        
        function maxviewangle = get.MaxViewAngle(obj)
            %get.MaxViewAngle Get the value for property MaxViewAngle
            maxviewangle = double(obj.JavaMessage.getMaxViewAngle);
        end
        
        function set.MaxViewAngle(obj, maxviewangle)
            %set.MaxViewAngle Set the value for property MaxViewAngle
            validateattributes(maxviewangle, {'numeric'}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'MaxViewAngle');
            
            obj.JavaMessage.setMaxViewAngle(maxviewangle);
        end
        
        function maxrangeangle = get.MaxRangeAngle(obj)
            %get.MaxRangeAngle Get the value for property MaxRangeAngle
            maxrangeangle = double(obj.JavaMessage.getMaxRangeAngle);
        end
        
        function set.MaxRangeAngle(obj, maxrangeangle)
            %set.MaxRangeAngle Set the value for property MaxRangeAngle
            validateattributes(maxrangeangle, {'numeric'}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'MaxRangeAngle');
            
            obj.JavaMessage.setMaxRangeAngle(maxrangeangle);
        end
        
        function sensorviewdirection = get.SensorViewDirection(obj)
            %get.SensorViewDirection Get the value for property SensorViewDirection
            sensorviewdirection = typecast(int8(obj.JavaMessage.getSensorViewDirection), 'uint8');
        end
        
        function set.SensorViewDirection(obj, sensorviewdirection)
            %set.SensorViewDirection Set the value for property SensorViewDirection
            validateattributes(sensorviewdirection, {'numeric'}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'SensorViewDirection');
            
            obj.JavaMessage.setSensorViewDirection(sensorviewdirection);
        end
        
        function weight = get.Weight(obj)
            %get.Weight Get the value for property Weight
            weight = double(obj.JavaMessage.getWeight);
        end
        
        function set.Weight(obj, weight)
            %set.Weight Set the value for property Weight
            validateattributes(weight, {'numeric'}, {'nonempty', 'scalar'}, 'VisibilityConstraint', 'Weight');
            
            obj.JavaMessage.setWeight(weight);
        end
    end
    
    methods (Access = protected)
        function resetCache(obj)
            %resetCache Resets any cached properties
            obj.Cache.TargetPose = [];
            obj.Cache.SensorPose = [];
        end
        
        function cpObj = copyElement(obj)
            %copyElement Implements deep copy behavior for message
            
            % Call default copy method for shallow copy
            cpObj = copyElement@robotics.ros.Message(obj);
            
            % Clear any existing cached properties
            cpObj.resetCache;
            
            % Create a new Java message object
            cpObj.JavaMessage = obj.createNewJavaMessage;
            
            % Iterate over all primitive properties
            cpObj.TargetRadius = obj.TargetRadius;
            cpObj.ConeSides = obj.ConeSides;
            cpObj.MaxViewAngle = obj.MaxViewAngle;
            cpObj.MaxRangeAngle = obj.MaxRangeAngle;
            cpObj.SensorViewDirection = obj.SensorViewDirection;
            cpObj.Weight = obj.Weight;
            
            % Recursively copy compound properties
            cpObj.TargetPose = copy(obj.TargetPose);
            cpObj.SensorPose = copy(obj.SensorPose);
        end
        
        function reload(obj, strObj)
            %reload Called by loadobj to assign properties
            obj.TargetRadius = strObj.TargetRadius;
            obj.ConeSides = strObj.ConeSides;
            obj.MaxViewAngle = strObj.MaxViewAngle;
            obj.MaxRangeAngle = strObj.MaxRangeAngle;
            obj.SensorViewDirection = strObj.SensorViewDirection;
            obj.Weight = strObj.Weight;
            obj.TargetPose = feval([obj.GeometryMsgsPoseStampedClass '.loadobj'], strObj.TargetPose);
            obj.SensorPose = feval([obj.GeometryMsgsPoseStampedClass '.loadobj'], strObj.SensorPose);
        end
    end
    
    methods (Access = ?robotics.ros.Message)
        function strObj = saveobj(obj)
            %saveobj Implements saving of message to MAT file
            
            % Return an empty element if object array is empty
            if isempty(obj)
                strObj = struct.empty;
                return
            end
            
            strObj.TargetRadius = obj.TargetRadius;
            strObj.ConeSides = obj.ConeSides;
            strObj.MaxViewAngle = obj.MaxViewAngle;
            strObj.MaxRangeAngle = obj.MaxRangeAngle;
            strObj.SensorViewDirection = obj.SensorViewDirection;
            strObj.Weight = obj.Weight;
            strObj.TargetPose = saveobj(obj.TargetPose);
            strObj.SensorPose = saveobj(obj.SensorPose);
        end
    end
    
    methods (Static, Access = {?matlab.unittest.TestCase, ?robotics.ros.Message})
        function obj = loadobj(strObj)
            %loadobj Implements loading of message from MAT file
            
            % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = robotics.ros.custom.msggen.moveit_msgs.VisibilityConstraint.empty(0,1);
                return
            end
            
            % Create an empty message object
            obj = robotics.ros.custom.msggen.moveit_msgs.VisibilityConstraint;
            obj.reload(strObj);
        end
    end
end
