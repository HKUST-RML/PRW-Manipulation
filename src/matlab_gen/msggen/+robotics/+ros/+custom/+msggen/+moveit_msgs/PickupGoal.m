classdef PickupGoal < robotics.ros.Message
    %PickupGoal MATLAB implementation of moveit_msgs/PickupGoal
    %   This class was automatically generated by
    %   robotics.ros.msg.internal.gen.MessageClassGenerator.
    
    %   Copyright 2014-2018 The MathWorks, Inc.
    
    %#ok<*INUSD>
    
    properties (Constant)
        MessageType = 'moveit_msgs/PickupGoal' % The ROS message type
    end
    
    properties (Constant, Hidden)
        MD5Checksum = '458c6ab3761d73e99b070063f7b74c2a' % The MD5 Checksum of the message definition
    end
    
    properties (Access = protected)
        JavaMessage % The Java message object
    end
    
    properties (Constant, Access = protected)
        MoveitMsgsConstraintsClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/Constraints') % Dispatch to MATLAB class for message type moveit_msgs/Constraints
        MoveitMsgsGraspClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/Grasp') % Dispatch to MATLAB class for message type moveit_msgs/Grasp
        MoveitMsgsPlanningOptionsClass = robotics.ros.msg.internal.MessageFactory.getClassForType('moveit_msgs/PlanningOptions') % Dispatch to MATLAB class for message type moveit_msgs/PlanningOptions
    end
    
    properties (Dependent)
        TargetName
        GroupName
        EndEffector
        SupportSurfaceName
        AllowGripperSupportCollision
        MinimizeObjectDistance
        PathConstraints
        PlannerId
        AllowedPlanningTime
        PlanningOptions
        PossibleGrasps
        AttachedObjectTouchLinks
        AllowedTouchObjects
    end
    
    properties (Access = protected)
        Cache = struct('PossibleGrasps', [], 'PathConstraints', [], 'PlanningOptions', []) % The cache for fast data access
    end
    
    properties (Constant, Hidden)
        PropertyList = {'AllowGripperSupportCollision', 'AllowedPlanningTime', 'AllowedTouchObjects', 'AttachedObjectTouchLinks', 'EndEffector', 'GroupName', 'MinimizeObjectDistance', 'PathConstraints', 'PlannerId', 'PlanningOptions', 'PossibleGrasps', 'SupportSurfaceName', 'TargetName'} % List of non-constant message properties
        ROSPropertyList = {'allow_gripper_support_collision', 'allowed_planning_time', 'allowed_touch_objects', 'attached_object_touch_links', 'end_effector', 'group_name', 'minimize_object_distance', 'path_constraints', 'planner_id', 'planning_options', 'possible_grasps', 'support_surface_name', 'target_name'} % List of non-constant ROS message properties
    end
    
    methods
        function obj = PickupGoal(msg)
            %PickupGoal Construct the message object PickupGoal
            import com.mathworks.toolbox.robotics.ros.message.MessageInfo;
            
            % Support default constructor
            if nargin == 0
                obj.JavaMessage = obj.createNewJavaMessage;
                return;
            end
            
            % Construct appropriate empty array
            if isempty(msg)
                obj = obj.empty(0,1);
                return;
            end
            
            % Make scalar construction fast
            if isscalar(msg)
                % Check for correct input class
                if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
                    error(message('robotics:ros:message:NoTypeMatch', obj.MessageType, ...
                        char(MessageInfo.getType(msg(1))) ));
                end
                obj.JavaMessage = msg(1);
                return;
            end
            
            % Check that this is a vector of scalar messages. Since this
            % is an object array, use arrayfun to verify.
            if ~all(arrayfun(@isscalar, msg))
                error(message('robotics:ros:message:MessageArraySizeError'));
            end
            
            % Check that all messages in the array have the correct type
            if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
                error(message('robotics:ros:message:NoTypeMatchArray', obj.MessageType));
            end
            
            % Construct array of objects if necessary
            objType = class(obj);
            for i = 1:length(msg)
                obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
            end
        end
        
        function targetname = get.TargetName(obj)
            %get.TargetName Get the value for property TargetName
            targetname = char(obj.JavaMessage.getTargetName);
        end
        
        function set.TargetName(obj, targetname)
            %set.TargetName Set the value for property TargetName
            validateattributes(targetname, {'char'}, {}, 'PickupGoal', 'TargetName');
            
            obj.JavaMessage.setTargetName(targetname);
        end
        
        function groupname = get.GroupName(obj)
            %get.GroupName Get the value for property GroupName
            groupname = char(obj.JavaMessage.getGroupName);
        end
        
        function set.GroupName(obj, groupname)
            %set.GroupName Set the value for property GroupName
            validateattributes(groupname, {'char'}, {}, 'PickupGoal', 'GroupName');
            
            obj.JavaMessage.setGroupName(groupname);
        end
        
        function endeffector = get.EndEffector(obj)
            %get.EndEffector Get the value for property EndEffector
            endeffector = char(obj.JavaMessage.getEndEffector);
        end
        
        function set.EndEffector(obj, endeffector)
            %set.EndEffector Set the value for property EndEffector
            validateattributes(endeffector, {'char'}, {}, 'PickupGoal', 'EndEffector');
            
            obj.JavaMessage.setEndEffector(endeffector);
        end
        
        function supportsurfacename = get.SupportSurfaceName(obj)
            %get.SupportSurfaceName Get the value for property SupportSurfaceName
            supportsurfacename = char(obj.JavaMessage.getSupportSurfaceName);
        end
        
        function set.SupportSurfaceName(obj, supportsurfacename)
            %set.SupportSurfaceName Set the value for property SupportSurfaceName
            validateattributes(supportsurfacename, {'char'}, {}, 'PickupGoal', 'SupportSurfaceName');
            
            obj.JavaMessage.setSupportSurfaceName(supportsurfacename);
        end
        
        function allowgrippersupportcollision = get.AllowGripperSupportCollision(obj)
            %get.AllowGripperSupportCollision Get the value for property AllowGripperSupportCollision
            allowgrippersupportcollision = logical(obj.JavaMessage.getAllowGripperSupportCollision);
        end
        
        function set.AllowGripperSupportCollision(obj, allowgrippersupportcollision)
            %set.AllowGripperSupportCollision Set the value for property AllowGripperSupportCollision
            validateattributes(allowgrippersupportcollision, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'PickupGoal', 'AllowGripperSupportCollision');
            
            obj.JavaMessage.setAllowGripperSupportCollision(allowgrippersupportcollision);
        end
        
        function minimizeobjectdistance = get.MinimizeObjectDistance(obj)
            %get.MinimizeObjectDistance Get the value for property MinimizeObjectDistance
            minimizeobjectdistance = logical(obj.JavaMessage.getMinimizeObjectDistance);
        end
        
        function set.MinimizeObjectDistance(obj, minimizeobjectdistance)
            %set.MinimizeObjectDistance Set the value for property MinimizeObjectDistance
            validateattributes(minimizeobjectdistance, {'logical', 'numeric'}, {'nonempty', 'scalar'}, 'PickupGoal', 'MinimizeObjectDistance');
            
            obj.JavaMessage.setMinimizeObjectDistance(minimizeobjectdistance);
        end
        
        function pathconstraints = get.PathConstraints(obj)
            %get.PathConstraints Get the value for property PathConstraints
            if isempty(obj.Cache.PathConstraints)
                obj.Cache.PathConstraints = feval(obj.MoveitMsgsConstraintsClass, obj.JavaMessage.getPathConstraints);
            end
            pathconstraints = obj.Cache.PathConstraints;
        end
        
        function set.PathConstraints(obj, pathconstraints)
            %set.PathConstraints Set the value for property PathConstraints
            validateattributes(pathconstraints, {obj.MoveitMsgsConstraintsClass}, {'nonempty', 'scalar'}, 'PickupGoal', 'PathConstraints');
            
            obj.JavaMessage.setPathConstraints(pathconstraints.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PathConstraints)
                obj.Cache.PathConstraints.setJavaObject(pathconstraints.getJavaObject);
            end
        end
        
        function plannerid = get.PlannerId(obj)
            %get.PlannerId Get the value for property PlannerId
            plannerid = char(obj.JavaMessage.getPlannerId);
        end
        
        function set.PlannerId(obj, plannerid)
            %set.PlannerId Set the value for property PlannerId
            validateattributes(plannerid, {'char'}, {}, 'PickupGoal', 'PlannerId');
            
            obj.JavaMessage.setPlannerId(plannerid);
        end
        
        function allowedplanningtime = get.AllowedPlanningTime(obj)
            %get.AllowedPlanningTime Get the value for property AllowedPlanningTime
            allowedplanningtime = double(obj.JavaMessage.getAllowedPlanningTime);
        end
        
        function set.AllowedPlanningTime(obj, allowedplanningtime)
            %set.AllowedPlanningTime Set the value for property AllowedPlanningTime
            validateattributes(allowedplanningtime, {'numeric'}, {'nonempty', 'scalar'}, 'PickupGoal', 'AllowedPlanningTime');
            
            obj.JavaMessage.setAllowedPlanningTime(allowedplanningtime);
        end
        
        function planningoptions = get.PlanningOptions(obj)
            %get.PlanningOptions Get the value for property PlanningOptions
            if isempty(obj.Cache.PlanningOptions)
                obj.Cache.PlanningOptions = feval(obj.MoveitMsgsPlanningOptionsClass, obj.JavaMessage.getPlanningOptions);
            end
            planningoptions = obj.Cache.PlanningOptions;
        end
        
        function set.PlanningOptions(obj, planningoptions)
            %set.PlanningOptions Set the value for property PlanningOptions
            validateattributes(planningoptions, {obj.MoveitMsgsPlanningOptionsClass}, {'nonempty', 'scalar'}, 'PickupGoal', 'PlanningOptions');
            
            obj.JavaMessage.setPlanningOptions(planningoptions.getJavaObject);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PlanningOptions)
                obj.Cache.PlanningOptions.setJavaObject(planningoptions.getJavaObject);
            end
        end
        
        function possiblegrasps = get.PossibleGrasps(obj)
            %get.PossibleGrasps Get the value for property PossibleGrasps
            if isempty(obj.Cache.PossibleGrasps)
                javaArray = obj.JavaMessage.getPossibleGrasps;
                array = obj.readJavaArray(javaArray, obj.MoveitMsgsGraspClass);
                obj.Cache.PossibleGrasps = feval(obj.MoveitMsgsGraspClass, array);
            end
            possiblegrasps = obj.Cache.PossibleGrasps;
        end
        
        function set.PossibleGrasps(obj, possiblegrasps)
            %set.PossibleGrasps Set the value for property PossibleGrasps
            if ~isvector(possiblegrasps) && isempty(possiblegrasps)
                % Allow empty [] input
                possiblegrasps = feval([obj.MoveitMsgsGraspClass '.empty'], 0, 1);
            end
            
            validateattributes(possiblegrasps, {obj.MoveitMsgsGraspClass}, {'vector'}, 'PickupGoal', 'PossibleGrasps');
            
            javaArray = obj.JavaMessage.getPossibleGrasps;
            array = obj.writeJavaArray(possiblegrasps, javaArray, obj.MoveitMsgsGraspClass);
            obj.JavaMessage.setPossibleGrasps(array);
            
            % Update cache if necessary
            if ~isempty(obj.Cache.PossibleGrasps)
                obj.Cache.PossibleGrasps = [];
                obj.Cache.PossibleGrasps = obj.PossibleGrasps;
            end
        end
        
        function attachedobjecttouchlinks = get.AttachedObjectTouchLinks(obj)
            %get.AttachedObjectTouchLinks Get the value for property AttachedObjectTouchLinks
            javaArray = obj.JavaMessage.getAttachedObjectTouchLinks;
            array = obj.readJavaArray(javaArray, 'char');
            attachedobjecttouchlinks = arrayfun(@(x) char(x), array, 'UniformOutput', false);
        end
        
        function set.AttachedObjectTouchLinks(obj, attachedobjecttouchlinks)
            %set.AttachedObjectTouchLinks Set the value for property AttachedObjectTouchLinks
            if ~isvector(attachedobjecttouchlinks) && isempty(attachedobjecttouchlinks)
                % Allow empty [] input
                attachedobjecttouchlinks = cell.empty(0,1);
            end
            
            validateattributes(attachedobjecttouchlinks, {'cell'}, {'vector'}, 'PickupGoal', 'AttachedObjectTouchLinks');
            if any(cellfun(@(x) ~ischar(x), attachedobjecttouchlinks))
                error(message('robotics:ros:message:CellArrayStringError', ...
                    'attachedobjecttouchlinks'));
            end
            
            javaArray = obj.JavaMessage.getAttachedObjectTouchLinks;
            array = obj.writeJavaArray(attachedobjecttouchlinks, javaArray, 'char');
            obj.JavaMessage.setAttachedObjectTouchLinks(array);
        end
        
        function allowedtouchobjects = get.AllowedTouchObjects(obj)
            %get.AllowedTouchObjects Get the value for property AllowedTouchObjects
            javaArray = obj.JavaMessage.getAllowedTouchObjects;
            array = obj.readJavaArray(javaArray, 'char');
            allowedtouchobjects = arrayfun(@(x) char(x), array, 'UniformOutput', false);
        end
        
        function set.AllowedTouchObjects(obj, allowedtouchobjects)
            %set.AllowedTouchObjects Set the value for property AllowedTouchObjects
            if ~isvector(allowedtouchobjects) && isempty(allowedtouchobjects)
                % Allow empty [] input
                allowedtouchobjects = cell.empty(0,1);
            end
            
            validateattributes(allowedtouchobjects, {'cell'}, {'vector'}, 'PickupGoal', 'AllowedTouchObjects');
            if any(cellfun(@(x) ~ischar(x), allowedtouchobjects))
                error(message('robotics:ros:message:CellArrayStringError', ...
                    'allowedtouchobjects'));
            end
            
            javaArray = obj.JavaMessage.getAllowedTouchObjects;
            array = obj.writeJavaArray(allowedtouchobjects, javaArray, 'char');
            obj.JavaMessage.setAllowedTouchObjects(array);
        end
    end
    
    methods (Access = protected)
        function resetCache(obj)
            %resetCache Resets any cached properties
            obj.Cache.PossibleGrasps = [];
            obj.Cache.PathConstraints = [];
            obj.Cache.PlanningOptions = [];
        end
        
        function cpObj = copyElement(obj)
            %copyElement Implements deep copy behavior for message
            
            % Call default copy method for shallow copy
            cpObj = copyElement@robotics.ros.Message(obj);
            
            % Clear any existing cached properties
            cpObj.resetCache;
            
            % Create a new Java message object
            cpObj.JavaMessage = obj.createNewJavaMessage;
            
            % Iterate over all primitive properties
            cpObj.TargetName = obj.TargetName;
            cpObj.GroupName = obj.GroupName;
            cpObj.EndEffector = obj.EndEffector;
            cpObj.SupportSurfaceName = obj.SupportSurfaceName;
            cpObj.AllowGripperSupportCollision = obj.AllowGripperSupportCollision;
            cpObj.MinimizeObjectDistance = obj.MinimizeObjectDistance;
            cpObj.PlannerId = obj.PlannerId;
            cpObj.AllowedPlanningTime = obj.AllowedPlanningTime;
            cpObj.AttachedObjectTouchLinks = obj.AttachedObjectTouchLinks;
            cpObj.AllowedTouchObjects = obj.AllowedTouchObjects;
            
            % Recursively copy compound properties
            cpObj.PathConstraints = copy(obj.PathConstraints);
            cpObj.PlanningOptions = copy(obj.PlanningOptions);
            cpObj.PossibleGrasps = copy(obj.PossibleGrasps);
        end
        
        function reload(obj, strObj)
            %reload Called by loadobj to assign properties
            obj.TargetName = strObj.TargetName;
            obj.GroupName = strObj.GroupName;
            obj.EndEffector = strObj.EndEffector;
            obj.SupportSurfaceName = strObj.SupportSurfaceName;
            obj.AllowGripperSupportCollision = strObj.AllowGripperSupportCollision;
            obj.MinimizeObjectDistance = strObj.MinimizeObjectDistance;
            obj.PlannerId = strObj.PlannerId;
            obj.AllowedPlanningTime = strObj.AllowedPlanningTime;
            obj.AttachedObjectTouchLinks = strObj.AttachedObjectTouchLinks;
            obj.AllowedTouchObjects = strObj.AllowedTouchObjects;
            obj.PathConstraints = feval([obj.MoveitMsgsConstraintsClass '.loadobj'], strObj.PathConstraints);
            obj.PlanningOptions = feval([obj.MoveitMsgsPlanningOptionsClass '.loadobj'], strObj.PlanningOptions);
            PossibleGraspsCell = arrayfun(@(x) feval([obj.MoveitMsgsGraspClass '.loadobj'], x), strObj.PossibleGrasps, 'UniformOutput', false);
            obj.PossibleGrasps = vertcat(PossibleGraspsCell{:});
        end
    end
    
    methods (Access = ?robotics.ros.Message)
        function strObj = saveobj(obj)
            %saveobj Implements saving of message to MAT file
            
            % Return an empty element if object array is empty
            if isempty(obj)
                strObj = struct.empty;
                return
            end
            
            strObj.TargetName = obj.TargetName;
            strObj.GroupName = obj.GroupName;
            strObj.EndEffector = obj.EndEffector;
            strObj.SupportSurfaceName = obj.SupportSurfaceName;
            strObj.AllowGripperSupportCollision = obj.AllowGripperSupportCollision;
            strObj.MinimizeObjectDistance = obj.MinimizeObjectDistance;
            strObj.PlannerId = obj.PlannerId;
            strObj.AllowedPlanningTime = obj.AllowedPlanningTime;
            strObj.AttachedObjectTouchLinks = obj.AttachedObjectTouchLinks;
            strObj.AllowedTouchObjects = obj.AllowedTouchObjects;
            strObj.PathConstraints = saveobj(obj.PathConstraints);
            strObj.PlanningOptions = saveobj(obj.PlanningOptions);
            strObj.PossibleGrasps = arrayfun(@(x) saveobj(x), obj.PossibleGrasps);
        end
    end
    
    methods (Static, Access = {?matlab.unittest.TestCase, ?robotics.ros.Message})
        function obj = loadobj(strObj)
            %loadobj Implements loading of message from MAT file
            
            % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = robotics.ros.custom.msggen.moveit_msgs.PickupGoal.empty(0,1);
                return
            end
            
            % Create an empty message object
            obj = robotics.ros.custom.msggen.moveit_msgs.PickupGoal;
            obj.reload(strObj);
        end
    end
end
